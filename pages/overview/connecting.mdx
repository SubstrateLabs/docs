import { Callout } from "nextra/components";
import { MultiComputeText, ComputeJSON } from "@/components/nodes";

<Callout emoji="֍">Learn how to connect nodes using futures</Callout>

Substrate requires connecting nodes before running them. When we connect two nodes, we use a **future** reference from the first node as an input to the second node.

Operators from the `sb` submodule are used to transform future values. Common transforms are included, and most other transforms can be expressed using [jq](https://jqlang.github.io/jq/), a powerful language for manipulating JSON data.

### See also

- Use [`Box`](/reference/box) to combine outputs into a single node
- Use [`If`](/reference/if) to return one of two options based on a condition
- Use [`RunPython`](/reference/run-python) to transform outputs with custom code

### Joining strings

<CH.Section>

Use `sb.concat` to join future and static strings.

<CH.Code>

```python Python
story = ComputeText(prompt="tell me a short story")
# mark
summary = ComputeText(prompt=sb.concat("summarize: ", story.future.text))
```

```typescript TypeScript
const story = new ComputeText({ prompt: "tell me a short story" });
const summary = new ComputeText({
  // mark
  prompt: sb.concat("summarize: ", story.future.text),
});
```

</CH.Code>

</CH.Section>
<CH.Section>

To join strings using a template, use `sb.interpolate` in TypeScript.

<CH.Code>

```typescript TypeScript
const story = new ComputeText({ prompt: "tell me a short story" });
const summary = new ComputeText({
  // mark
  prompt: sb.interpolate`summarize: ${story.future.text}`,
});
```

</CH.Code>

</CH.Section>

### Future dictionary values

<CH.Section>

- In Python, simply use brackets as usual.
- In TypeScript, use _`.get()`_ to reference untyped future object values.

<CH.Code>

```python Python
author = ComputeJSON(
  prompt="Who wrote Don Quixote?",
  json_schema={
    "type": "object",
    "properties": {
        "author": {
        "type": "string",
        "description": "The name of the author.",
      },
    },
  },
)
summary = ComputeText(
  prompt=sb.concat(
    "Write a haiku describing ",
    # mark
    author.future.json_object["author"]),
  ),
)
```

```typescript TypeScript
const author = new ComputeJSON({
  prompt: "Who wrote Don Quixote?",
  json_schema: {
    type: "object",
    properties: {
      author: {
        type: "string",
        description: "The name of the author.",
      },
    },
  },
});
const summary = new ComputeText({
  prompt: sb.concat(
    "Write a haiku describing ",
    // mark
    author.future.json_object.get("author")),
  ),
});
```

</CH.Code>

</CH.Section>

### Future array items

<CH.Section>

- In Python, simply use brackets as usual.
- In TypeScript, use _`.at()`_ to index future arrays.

<CH.Code>

```python Python
story = MultiComputeText(prompt="tell me a short story", num_choices=2)
summary = ComputeText(
  # mark
  prompt=sb.concat("summarize: ", story.future.choices[0].text),
)
```

```typescript TypeScript
const story = new MultiComputeText({
  prompt: "tell me a short story",
  num_choices: 2,
});
const summary = new ComputeText({
  // mark
  prompt: sb.concat("summarize: ", story.future.choices.at(0).text),
});
```

</CH.Code>

</CH.Section>

### Parsing strings

<CH.Section>

Use `sb.jq` to parse strings before passing them to other nodes.

<CH.Code>

```python Python
name = ComputeText(
    prompt="Give me a unique startup name inside <name></name> tags. Example: <name>Hyphae</name><description>A startup that ... </description>",
)
haiku = ComputeText(
    prompt=sb.concat(
        "Write a haiku describing a startup named: ",
        sb.jq(
            name.future.text,
            'ascii_downcase | split("<name>") | .[1] | split("</name>") | .[0]',
        ),
    ),
)
```

```typescript TypeScript
const name = new ComputeText({
  prompt:
    "Give me a unique startup name inside <name></name> tags. Example: <name>Hyphae</name><description>A startup that ... </description>",
});
const haiku = new ComputeText({
  prompt: sb.concat(
    "Write a haiku describing a startup named: ",
    sb.jq(
      name.future.text,
      'ascii_downcase | split("<name>") | .[1] | split("</name>") | .[0]',
    ),
  ),
});
```

</CH.Code>

<details>
<summary>Learn more</summary>
The `jq` pipeline above is an example of what's possible using the [`jq` language](https://jqlang.github.io/jq/manual/#basic-filters).

- `jq` takes any JSON value as input and produces a JSON value as output. JSON values include dictionaries, arrays, strings, numbers, and booleans.
- The _`.`_ dot syntax can be used to filter by a data path: _`.[0].text`_
- The _`|`_ pipe operator is used to chain together `jq` expressions.

In this `jq` example, we're [downcasing](https://jqlang.github.io/jq/manual/#ascii_downcase-ascii_upcase) the string, [splitting](https://jqlang.github.io/jq/manual/#split-2) by the opening `<name>` tag, [indexing](https://jqlang.github.io/jq/manual/#array-index) the second item in the resulting array, splitting by the closing `</name>` tag, and finally returning the first value in the resulting array:

- `ascii_downcase | split("<name>") | .[1] | split("</name>") | .[0]`

Alternatively, you can use `jq`'s [capture](https://jqlang.github.io/jq/manual/#capture) function with a regular expression:

- `capture("<name>(?<content>.*?)</name>") | .content`
</details>

</CH.Section>
